#include <iostream>      // Для ввода-вывода в консоль (cout, cerr)
#include <fstream>       // Для работы с файлами (ofstream)
#include <cmath>         // Для математических функций, таких как std::abs и std::cos
#include <vector>        // Для использования std::vector — динамических массивов
#include <random>        // Для генерации случайных чисел (random_device, mt19937, uniform_real_distribution)
#include <array>         // Для работы с массивами (здесь не используется напрямую, можно убрать)

// Структура для хранения состояния частицы: координаты (x) и скорости (v)
struct State {
    double x;  // Позиция частицы в пространстве
    double v;  // Скорость частицы
};

// Функция, описывающая уравнение Дюффинга (производные по времени для x и v)
void duffing(const State& s, State& dsdt, double t, 
             double delta, double alpha, double beta, double gamma, double omega) {
    dsdt.x = s.v;  // dx/dt = v (производная координаты — это скорость)
    dsdt.v = -delta * s.v - alpha * s.x - beta * s.x * s.x * s.x + gamma * std::cos(omega * t); 
    // dv/dt = -δv - αx - βx³ + γcos(ωt) — уравнение Дюффинга с затуханием, линейной и нелинейной упругостью, и внешней силой
}

// Универсальная функция для одного шага метода Рунге-Кутты (используется для RK4)
void rk_step(State& s, double t, double dt, 
             const std::vector<double>& c, 
             const std::vector<std::vector<double>>& a,
             const std::vector<double>& b,
             double delta, double alpha, double beta, double gamma, double omega) {
    int stages = c.size();  // Количество стадий метода (например, 4 для RK4)
    std::vector<State> k(stages);  // Вектор промежуточных значений k для каждой стадии
    State s_temp = s;  // Временная копия состояния для промежуточных вычислений

    // Цикл по стадиям метода Рунге-Кутты
    for (int i = 0; i < stages; i++) {
        State sum_a_k = {0.0, 0.0};  // Сумма a[i][j] * k[j] для текущей стадии
        for (int j = 0; j < i; j++) {
            sum_a_k.x += a[i][j] * k[j].x;  // Взвешенная сумма по x для предыдущих k
            sum_a_k.v += a[i][j] * k[j].v;  // Взвешенная сумма по v для предыдущих k
        }
        s_temp.x = s.x + dt * sum_a_k.x;  // Обновляем временное состояние x
        s_temp.v = s.v + dt * sum_a_k.v;  // Обновляем временное состояние v
        duffing(s_temp, k[i], t + c[i] * dt, delta, alpha, beta, gamma, omega);  // Вычисляем k[i]
    }

    State ds = {0.0, 0.0};  // Итоговое приращение состояния
    for (int i = 0; i < stages; i++) {
        ds.x += b[i] * k[i].x;  // Взвешенная сумма k по x с коэффициентами b
        ds.v += b[i] * k[i].v;  // Взвешенная сумма k по v с коэффициентами b
    }
    s.x += dt * ds.x;  // Обновляем координату частицы
    s.v += dt * ds.v;  // Обновляем скорость частицы
}

// Функция для метода Дорманда-Принса 8(5,3) с использованием FSAL
void dp8_step(State& s, double t, double dt, 
              State& k_last, bool first_step,  // k_last — последняя стадия, first_step — флаг первого шага
              const std::vector<double>& c, 
              const std::vector<std::vector<double>>& a,
              const std::vector<double>& b,
              double delta, double alpha, double beta, double gamma, double omega) {
    const int stages = 13;  // Число стадий метода DP8 (фиксировано для метода 8(5,3))
    std::vector<State> k(stages);  // Вектор промежуточных значений k для каждой стадии
    State s_temp = s;  // Временная копия состояния для промежуточных вычислений

    if (first_step) {
        // Первый шаг: вычисляем все 13 стадий, так как нет предыдущего k_last
        for (int i = 0; i < stages; i++) {
            State sum_a_k = {0.0, 0.0};  // Сумма a[i][j] * k[j] для текущей стадии
            for (int j = 0; j < i; j++) {
                sum_a_k.x += a[i][j] * k[j].x;  // Взвешенная сумма по x
                sum_a_k.v += a[i][j] * k[j].v;  // Взвешенная сумма по v
            }
            s_temp.x = s.x + dt * sum_a_k.x;  // Обновляем временное состояние x
            s_temp.v = s.v + dt * sum_a_k.v;  // Обновляем временное состояние v
            duffing(s_temp, k[i], t + c[i] * dt, delta, alpha, beta, gamma, omega);  // Вычисляем k[i]
        }
    } else {
        // Последующие шаги: используем k_last как k[0] благодаря FSAL
        k[0] = k_last;  // Первая стадия — это последняя стадия предыдущего шага
        for (int i = 1; i < stages; i++) {  // Вычисляем только стадии с 1 по 12
            State sum_a_k = {0.0, 0.0};  // Сумма a[i][j] * k[j]
            for (int j = 0; j < i; j++) {
                sum_a_k.x += a[i][j] * k[j].x;  // Взвешенная сумма по x
                sum_a_k.v += a[i][j] * k[j].v;  // Взвешенная сумма по v
            }
            s_temp.x = s.x + dt * sum_a_k.x;  // Обновляем временное состояние x
            s_temp.v = s.v + dt * sum_a_k.v;  // Обновляем временное состояние v
            duffing(s_temp, k[i], t + c[i] * dt, delta, alpha, beta, gamma, omega);  // Вычисляем k[i]
        }
    }

    State ds = {0.0, 0.0};  // Итоговое приращение состояния
    for (int i = 0; i < stages; i++) {
        ds.x += b[i] * k[i].x;  // Взвешенная сумма k по x с коэффициентами b
        ds.v += b[i] * k[i].v;  // Взвешенная сумма k по v с коэффициентами b
    }
    s.x += dt * ds.x;  // Обновляем координату частицы
    s.v += dt * ds.v;  // Обновляем скорость частицы
    k_last = k[stages - 1];  // Сохраняем последнюю стадию (k[12]) для следующего шага
}

int main() {
    // Параметры уравнения Дюффинга
    double delta = 0.00001;  // Коэффициент затухания
    double alpha = 0.5;      // Линейная жёсткость
    double beta = 0.0625;    // Нелинейная жёсткость
    double gamma = 5;        // Амплитуда внешней силы
    double omega = 2.0;      // Частота внешней силы
    
    // Параметры моделирования
    double dt = 0.01;        // Шаг времени
    double T = 200.0;        // Общее время моделирования
    int steps = static_cast<int>(T / dt);  // Количество временных шагов
    int N = 1000;            // Количество частиц

    // Коэффициенты для метода RK4 (4 стадии)
    std::vector<double> c_rk4 = {0.0, 0.5, 0.5, 1.0};  // Временные точки для стадий
    std::vector<std::vector<double>> a_rk4 = {  // Матрица Бутчера для RK4
        {0.0},
        {0.5, 0.0},
        {0.0, 0.5, 0.0},
        {0.0, 0.0, 1.0}
    };
    std::vector<double> b_rk4 = {1.0/6.0, 1.0/3.0, 1.0/3.0, 1.0/6.0};  // Веса для итогового шага

    // Коэффициенты для метода Дорманда-Принса 8(5,3) (13 стадий)
    std::vector<double> c_dp = {
        0.0, 1.0/18.0, 1.0/12.0, 1.0/8.0, 5.0/16.0, 3.0/8.0, 
        59.0/400.0, 93.0/200.0, 5490023248.0/9719169821.0, 
        13.0/20.0, 1201146811.0/1299019798.0, 1.0, 1.0
    };
    std::vector<std::vector<double>> a_dp = {  // Матрица Бутчера для DP8
        {0.0},
        {1.0/18.0, 0.0},
        {1.0/48.0, 1.0/16.0, 0.0},
        {1.0/32.0, 0.0, 3.0/32.0, 0.0},
        {5.0/16.0, 0.0, -75.0/64.0, 75.0/64.0, 0.0},
        {3.0/80.0, 0.0, 0.0, 3.0/16.0, 3.0/20.0, 0.0},
        {29443841.0/614563906.0, 0.0, 0.0, 77736538.0/692538347.0, -28693883.0/1125000000.0, 23124283.0/1800000000.0, 0.0},
        {16016141.0/946692911.0, 0.0, 0.0, 61564180.0/158732637.0, 22789713.0/633445777.0, 545815736.0/2771057229.0, -180193667.0/1043307555.0, 0.0},
        {39632708.0/573591083.0, 0.0, 0.0, -433636366.0/683701615.0, -421739975.0/2616292301.0, 100302831.0/723423059.0, 790204164.0/839813087.0, 800635310.0/3783071287.0, 0.0},
        {246121993.0/1340847787.0, 0.0, 0.0, -37695042795.0/15268766246.0, -309121744.0/1061227803.0, -12992083.0/490766935.0, 6005943493.0/2108947869.0, 393006217.0/1396673457.0, 123872331.0/1001029789.0, 0.0},
        {-1028468189.0/846180014.0, 0.0, 0.0, 8478235783.0/508512852.0, 1311729495.0/1432422823.0, -10304129995.0/1701304382.0, -48777925059.0/3047939560.0, 15336726248.0/1032824649.0, -45442868181.0/3398467696.0, 3065993473.0/597172653.0, 0.0},
        {185892177.0/718116043.0, 0.0, 0.0, -3185094517.0/667107341.0, -477755414.0/1098053517.0, -703635378.0/230739211.0, 5731566787.0/1027545527.0, 5232866602.0/850066563.0, -4093664535.0/808688257.0, 3962137247.0/1805957418.0, 65686358.0/487910083.0, 0.0},
        {403863854.0/491063109.0, 0.0, 0.0, -5068492393.0/434740067.0, -411421997.0/543043805.0, 652783627.0/914296604.0, 11173962825.0/925320556.0, -13158990841.0/6184727034.0, 3936647629.0/1978049680.0, -160528059.0/685178525.0, 248638103.0/1413531060.0, 0.0}
    };
    std::vector<double> b_dp = {  // Веса для итогового шага DP8
        13451932.0/455176623.0, 0.0, 0.0, 0.0, 0.0, 
        -808719846.0/976000145.0, 1757004468.0/5645159321.0, 
        656045339.0/265891186.0, -3867574721.0/1518517206.0, 
        465885868.0/322736535.0, 53011238.0/667516719.0, 2.0/45.0, 0.0
    };

    // Векторы для хранения состояния частиц для RK4 и DP8
    std::vector<State> particles_rk4(N);  // Состояния частиц для метода RK4
    std::vector<State> particles_dp(N);   // Состояния частиц для метода DP8
    std::vector<State> k_last(N);         // Вектор для хранения последней стадии DP8 для каждой частицы (FSAL)

    // Инициализация генератора случайных чисел
    std::random_device rd;  // Источник энтропии для генерации случайных чисел
    std::mt19937 gen(rd());  // Генератор Мерсенна Твистера для случайных чисел
    std::uniform_real_distribution<double> dist_x(-10.0, 10.0);  // Равномерное распределение для x в диапазоне [-10, 10]
    std::uniform_real_distribution<double> dist_v(-10.0, 10.0);  // Равномерное распределение для v в диапазоне [-10, 10]

    // Задаём случайные начальные условия для всех частиц
    for (int i = 0; i < N; i++) {
        particles_rk4[i].x = particles_dp[i].x = dist_x(gen);  // Одинаковые начальные x для RK4 и DP8
        particles_rk4[i].v = particles_dp[i].v = dist_v(gen);  // Одинаковые начальные v для RK4 и DP8
    }

    // Открываем файлы для записи результатов
    std::ofstream fout_rk4("duffing_rk4.dat");  // Файл для данных RK4 (x и v для всех частиц)
    std::ofstream fout_dp("duffing_dp.dat");    // Файл для данных DP8 (x и v для всех частиц)
    std::ofstream fout_diff("diff.dat");        // Файл для средних локальных ошибок между RK4 и DP8
    if (!fout_rk4.is_open() || !fout_dp.is_open() || !fout_diff.is_open()) {
        std::cerr << "Ошибка открытия файлов!\n";  // Сообщение об ошибке, если файлы не удалось открыть
        return 1;  // Завершаем программу с ошибкой
    }

    double t = 0.0;  // Начальное время моделирования
    double max_global_diff_x = 0.0;  // Максимальная глобальная разность по x между RK4 и DP8
    double max_global_diff_v = 0.0;  // Максимальная глобальная разность по v между RK4 и DP8

    // Основной цикл по времени
    for (int i = 0; i < steps; i++) {
        double sum_diff_x = 0.0;  // Сумма разностей по x для вычисления среднего
        double sum_diff_v = 0.0;  // Сумма разностей по v для вычисления среднего
        double max_local_diff_x = 0.0;  // Максимальная локальная разность по x на текущем шаге
        double max_local_diff_v = 0.0;  // Максимальная локальная разность по v на текущем шаге

        // Цикл по частицам: запись данных и вычисление ошибок
        for (int j = 0; j < N; j++) {
            fout_rk4 << particles_rk4[j].x << " " << particles_rk4[j].v << " ";  // Записываем x и v для RK4
            fout_dp << particles_dp[j].x << " " << particles_dp[j].v << " ";     // Записываем x и v для DP8

            double diff_x = std::abs(particles_rk4[j].x - particles_dp[j].x);  // Разность по x между RK4 и DP8
            double diff_v = std::abs(particles_rk4[j].v - particles_dp[j].v);  // Разность по v между RK4 и DP8
            sum_diff_x += diff_x;  // Накапливаем сумму разностей по x
            sum_diff_v += diff_v;  // Накапливаем сумму разностей по v

            max_local_diff_x = std::max(max_local_diff_x, diff_x);  // Обновляем максимум по x на текущем шаге
            max_local_diff_v = std::max(max_local_diff_v, diff_v);  // Обновляем максимум по v на текущем шаге
            max_global_diff_x = std::max(max_global_diff_x, diff_x);  // Обновляем глобальный максимум по x
            max_global_diff_v = std::max(max_global_diff_v, diff_v);  // Обновляем глобальный максимум по v
        }
        double avg_local_diff_x = sum_diff_x / N;  // Средняя локальная ошибка по x
        double avg_local_diff_v = sum_diff_v / N;  // Средняя локальная ошибка по v
        fout_diff << avg_local_diff_x << " " << avg_local_diff_v << "\n";  // Записываем средние ошибки в файл

        fout_rk4 << "\n";  // Переход на новую строку после записи всех частиц для RK4
        fout_dp << "\n";   // Переход на новую строку после записи всех частиц для DP8

        // Обновление состояния всех частиц на следующем шаге
        for (int j = 0; j < N; j++) {
            rk_step(particles_rk4[j], t, dt, c_rk4, a_rk4, b_rk4, delta, alpha, beta, gamma, omega);  // Шаг RK4
            dp8_step(particles_dp[j], t, dt, k_last[j], (i == 0), c_dp, a_dp, b_dp, delta, alpha, beta, gamma, omega);  // Шаг DP8 с FSAL
        }
        t += dt;  // Увеличиваем время на шаг dt
    }

    // Закрываем файлы после записи всех данных
    fout_rk4.close();
    fout_dp.close();
    fout_diff.close();

    // Выводим итоговые сообщения в консоль
    std::cout << "Готово! Данные сохранены в 'duffing_rk4.dat', 'duffing_dp.dat' и 'diff.dat'.\n";
    std::cout << "Максимальная глобальная разница по x: " << max_global_diff_x << "\n";  // Максимальная разность по x за всё время
    std::cout << "Максимальная глобальная разница по v: " << max_global_diff_v << "\n";  // Максимальная разность по v за всё время

    return 0;
}
