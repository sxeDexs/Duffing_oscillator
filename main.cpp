#include <iostream>      // Для ввода-вывода в консоль (cout, cerr)
#include <fstream>       // Для работы с файлами (ofstream)
#include <cmath>         // Для математических функций, таких как std::abs и std::cos
#include <vector>        // Для использования std::vector — динамических массивов
#include <random>        // Для генерации случайных чисел (random_device, mt19937, uniform_real_distribution)

// Структура для хранения состояния частицы: координаты (x) и скорости (v)
struct State {
    double x;  // Позиция частицы в пространстве
    double v;  // Скорость частицы
};

// Функция, описывающая уравнение Дюффинга (производные по времени для x и v)
void duffing(const State& s, State& dsdt, double t, 
             double delta, double alpha, double beta, double gamma, double omega) {
    dsdt.x = s.v;  // dx/dt = v (производная координаты — это скорость)
    dsdt.v = -delta * s.v - alpha * s.x - beta * s.x * s.x * s.x + gamma * std::cos(omega * t); 
    // dv/dt = -δv - αx - βx³ + γcos(ωt) — уравнение Дюффинга с затуханием, линейной и нелинейной упругостью, и внешней силой
}

// Универсальная функция для одного шага метода Рунге-Кутты (для RK4 и RK6)
void rk_step(State& s, double t, double dt, 
             const std::vector<double>& c, 
             const std::vector<double>& a,  // Одномерный вектор для матрицы Бутчера
             const std::vector<double>& b,  // Веса для итогового шага
             int stages,                    // Количество стадий метода
             double delta, double alpha, double beta, double gamma, double omega) {
    std::vector<State> k(stages);  // Вектор промежуточных значений k для каждой стадии
    State s_temp = s;  // Временная копия состояния для промежуточных вычислений

    // Цикл по стадиям метода Рунге-Кутты
    for (int i = 0; i < stages; i++) {
        State sum_a_k = {0.0, 0.0};  // Сумма a[i][j] * k[j] для текущей стадии
        for (int j = 0; j < i; j++) {
            sum_a_k.x += a[i * stages + j] * k[j].x;  // Индексация одномерного массива: i * stages + j
            sum_a_k.v += a[i * stages + j] * k[j].v;  // Взвешенная сумма по v для предыдущих k
        }
        s_temp.x = s.x + dt * sum_a_k.x;  // Обновляем временное состояние x
        s_temp.v = s.v + dt * sum_a_k.v;  // Обновляем временное состояние v
        duffing(s_temp, k[i], t + c[i] * dt, delta, alpha, beta, gamma, omega);  // Вычисляем k[i]
    }

    State ds = {0.0, 0.0};  // Итоговое приращение состояния
    for (int i = 0; i < stages; i++) {
        ds.x += b[i] * k[i].x;  // Взвешенная сумма k по x с коэффициентами b
        ds.v += b[i] * k[i].v;  // Взвешенная сумма k по v с коэффициентами b
    }
    s.x += dt * ds.x;  // Обновляем координату частицы
    s.v += dt * ds.v;  // Обновляем скорость частицы
}

// Функция для метода Дорманда-Принса 8 с использованием FSAL (шаг фиксированный)
void dp8_step(State& s, double t, double dt, 
              State& k_last, bool first_step,  // k_last — последняя стадия, first_step — флаг первого шага
              const std::vector<double>& c, 
              const std::vector<double>& a,    // Одномерный вектор для матрицы Бутчера
              const std::vector<double>& b,    // Веса для итогового шага
              double delta, double alpha, double beta, double gamma, double omega) {
    const int stages = 13;  // Число стадий метода Dopri8
    std::vector<State> k(stages);  // Вектор промежуточных значений k для каждой стадии
    State s_temp = s;  // Временная копия состояния для промежуточных вычислений

    if (first_step) {
        // Первый шаг: вычисляем все 13 стадий, так как нет предыдущего k_last
        for (int i = 0; i < stages; i++) {
            State sum_a_k = {0.0, 0.0};  // Сумма a[i][j] * k[j] для текущей стадии
            for (int j = 0; j < i; j++) {
                sum_a_k.x += a[i * stages + j] * k[j].x;  // Индексация одномерного массива
                sum_a_k.v += a[i * stages + j] * k[j].v;  // Взвешенная сумма по v
            }
            s_temp.x = s.x + dt * sum_a_k.x;  // Обновляем временное состояние x
            s_temp.v = s.v + dt * sum_a_k.v;  // Обновляем временное состояние v
            duffing(s_temp, k[i], t + c[i] * dt, delta, alpha, beta, gamma, omega);  // Вычисляем k[i]
        }
    } else {
        // Последующие шаги: используем k_last как k[0] благодаря FSAL
        k[0] = k_last;  // Первая стадия — это последняя стадия предыдущего шага
        for (int i = 1; i < stages; i++) {  // Вычисляем только стадии с 1 по 12
            State sum_a_k = {0.0, 0.0};  // Сумма a[i][j] * k[j]
            for (int j = 0; j < i; j++) {
                sum_a_k.x += a[i * stages + j] * k[j].x;  // Индексация одномерного массива
                sum_a_k.v += a[i * stages + j] * k[j].v;  // Взвешенная сумма по v
            }
            s_temp.x = s.x + dt * sum_a_k.x;  // Обновляем временное состояние x
            s_temp.v = s.v + dt * sum_a_k.v;  // Обновляем временное состояние v
            duffing(s_temp, k[i], t + c[i] * dt, delta, alpha, beta, gamma, omega);  // Вычисляем k[i]
        }
    }

    State ds = {0.0, 0.0};  // Итоговое приращение состояния
    for (int i = 0; i < stages; i++) {
        ds.x += b[i] * k[i].x;  // Взвешенная сумма k по x с коэффициентами b
        ds.v += b[i] * k[i].v;  // Взвешенная сумма k по v с коэффициентами b
    }
    s.x += dt * ds.x;  // Обновляем координату частицы
    s.v += dt * ds.v;  // Обновляем скорость частицы
    k_last = k[stages - 1];  // Сохраняем последнюю стадию (k[12]) для следующего шага
}

int main() {
    // Параметры уравнения Дюффинга
    double delta = 0.00001;  // Коэффициент затухания
    double alpha = 0.5;      // Линейная жёсткость
    double beta = 0.0625;    // Нелинейная жёсткость
    double gamma = 5;        // Амплитуда внешней силы
    double omega = 2.0;      // Частота внешней силы
    
    // Параметры моделирования
    double dt = 0.001;        // Шаг времени (фиксированный)
    double T = 20.0;        // Общее время моделирования
    int steps = static_cast<int>(T / dt);  // Количество временных шагов
    int N = 500;            // Количество частиц

    // Коэффициенты для метода RK4 (4 стадии)
    std::vector<double> c_rk4 = {0.0, 0.5, 0.5, 1.0};  // Временные точки для стадий
    std::vector<double> a_rk4 = {  // Одномерный вектор для матрицы Бутчера (4x4)
        0.0, 0.0, 0.0, 0.0,       // i=0: все нули
        0.5, 0.0, 0.0, 0.0,       // i=1: a[1][0] = 0.5
        0.0, 0.5, 0.0, 0.0,       // i=2: a[2][1] = 0.5
        0.0, 0.0, 1.0, 0.0        // i=3: a[3][2] = 1.0
    };
    std::vector<double> b_rk4 = {1.0/6.0, 1.0/3.0, 1.0/3.0, 1.0/6.0};  // Веса для итогового шага
    const int stages_rk4 = 4;  // Количество стадий для RK4

    // Коэффициенты для метода Дорманда-Принса 8 (13 стадий, фиксированный шаг)
    std::vector<double> c_dp8 = {
        0.0, 1.0/18.0, 1.0/12.0, 1.0/8.0, 5.0/16.0, 3.0/8.0, 
        59.0/400.0, 93.0/200.0, 5490023248.0/9719169821.0, 
        13.0/20.0, 1201146811.0/1299019798.0, 1.0, 1.0
    };
    std::vector<double> a_dp8 = {  // Одномерный вектор для матрицы Бутчера (13x13)
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0/18.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0/48.0, 1.0/16.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0/32.0, 0.0, 3.0/32.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        5.0/16.0, 0.0, -75.0/64.0, 75.0/64.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        3.0/80.0, 0.0, 0.0, 3.0/16.0, 3.0/20.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        29443841.0/614563906.0, 0.0, 0.0, 77736538.0/692538347.0, -28693883.0/1125000000.0, 23124283.0/1800000000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        16016141.0/946692911.0, 0.0, 0.0, 61564180.0/158732637.0, 22789713.0/633445777.0, 545815736.0/2771057229.0, -180193667.0/1043307555.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        39632708.0/573591083.0, 0.0, 0.0, -433636366.0/683701615.0, -421739975.0/2616292301.0, 100302831.0/723423059.0, 790204164.0/839813087.0, 800635310.0/3783071287.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        246121993.0/1340847787.0, 0.0, 0.0, -37695042795.0/15268766246.0, -309121744.0/1061227803.0, -12992083.0/490766935.0, 6005943493.0/2108947869.0, 393006217.0/1396673457.0, 123872331.0/1001029789.0, 0.0, 0.0, 0.0, 0.0,
        -1028468189.0/846180014.0, 0.0, 0.0, 8478235783.0/508512852.0, 1311729495.0/1432422823.0, -10304129995.0/1701304382.0, -48777925059.0/3047939560.0, 15336726248.0/1032824649.0, -45442868181.0/3398467696.0, 3065993473.0/597172653.0, 0.0, 0.0, 0.0,
        185892177.0/718116043.0, 0.0, 0.0, -3185094517.0/667107341.0, -477755414.0/1098053517.0, -703635378.0/230739211.0, 5731566787.0/1027545527.0, 5232866602.0/850066563.0, -4093664535.0/808688257.0, 3962137247.0/1805957418.0, 65686358.0/487910083.0, 0.0, 0.0,
        403863854.0/491063109.0, 0.0, 0.0, -5068492393.0/434740067.0, -411421997.0/543043805.0, 652783627.0/914296604.0, 11173962825.0/925320556.0, -13158990841.0/6184727034.0, 3936647629.0/1978049680.0, -160528059.0/685178525.0, 248638103.0/1413531060.0, 0.0, 0.0
    };
    std::vector<double> b_dp8 = {  // Веса для итогового шага Dopri8
        13451932.0/455176623.0, 0.0, 0.0, 0.0, 0.0, 
        -808719846.0/976000145.0, 1757004468.0/5645159321.0, 
        656045339.0/265891186.0, -3867574721.0/1518517206.0, 
        465885868.0/322736535.0, 53011238.0/667516719.0, 2.0/45.0, 0.0
    };
    const int stages_dp8 = 13;  // Количество стадий для Dopri8

    // Коэффициенты для метода RK6 (8 стадий)
    std::vector<double> c_rk6 = {0.0, 1.0/10.0, 2.0/9.0, 3.0/7.0, 3.0/5.0, 4.0/5.0, 1.0, 1.0};  // Временные точки для стадий
    std::vector<double> a_rk6 = {  // Одномерный вектор для матрицы Бутчера (8x8)
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0/10.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        -2.0/81.0, 20.0/81.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        615.0/1372.0, -270.0/343.0, 1053.0/1372.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        3243.0/5500.0, -54.0/55.0, 50949.0/71500.0, 4998.0/17875.0, 0.0, 0.0, 0.0, 0.0,
        -26492.0/37125.0, 72.0/55.0, 2808.0/23375.0, -24206.0/37125.0, 338.0/459.0, 0.0, 0.0, 0.0,
        5561.0/2376.0, -35.0/11.0, -24117.0/31603.0, 899983.0/200772.0, -5225.0/1836.0, 3925.0/4056.0, 0.0, 0.0,
        465467.0/266112.0, -2945.0/1232.0, -5610201.0/14158144.0, 10513573.0/3212352.0, -424325.0/205632.0, 376225.0/454272.0, 0.0, 0.0
    };
    std::vector<double> b_rk6 = {821.0/10800.0, 0.0, 19683.0/71825.0, 175273.0/912600.0, 395.0/3672.0, 785.0/2704.0, 3.0/50.0, 0.0};  // Веса для итогового шага
    const int stages_rk6 = 8;  // Количество стадий для RK6

    // Векторы для хранения состояния частиц для RK4, Dopri8 и RK6
    std::vector<State> particles_rk4(N);  // Состояния частиц для метода RK4
    std::vector<State> particles_dp8(N);  // Состояния частиц для метода Dopri8
    std::vector<State> particles_rk6(N);  // Состояния частиц для метода RK6
    std::vector<State> k_last(N);         // Вектор для хранения последней стадии Dopri8 для каждой частицы (FSAL)

    // Инициализация генератора случайных чисел
    std::random_device rd;  // Источник энтропии для генерации случайных чисел
    std::mt19937 gen(rd());  // Генератор Мерсенна Твистера для случайных чисел
    std::uniform_real_distribution<double> dist_x(-10.0, 10.0);  // Равномерное распределение для x в диапазоне [-10, 10]
    std::uniform_real_distribution<double> dist_v(-10.0, 10.0);  // Равномерное распределение для v в диапазоне [-10, 10]

    // Задаём случайные начальные условия для всех частиц
    for (int i = 0; i < N; i++) {
        particles_rk4[i].x = particles_dp8[i].x = particles_rk6[i].x = dist_x(gen);  // Одинаковые начальные x для всех методов
        particles_rk4[i].v = particles_dp8[i].v = particles_rk6[i].v = dist_v(gen);  // Одинаковые начальные v для всех методов
    }

    // Открываем файлы для записи результатов
    std::ofstream fout_rk4("duffing_rk4.dat");   // Файл для данных RK4
    std::ofstream fout_dp8("duffing_dp8.dat");   // Файл для данных Dopri8
    std::ofstream fout_rk6("duffing_rk6.dat");   // Файл для данных RK6
    std::ofstream fout_diff_rk4_dp8("diff_rk4_dp8.dat");  // Файл для локальных разностей RK4 vs Dopri8
    std::ofstream fout_diff_rk6_dp8("diff_rk6_dp8.dat");  // Файл для локальных разностей RK6 vs Dopri8
    if (!fout_rk4.is_open() || !fout_dp8.is_open() || !fout_rk6.is_open() || 
        !fout_diff_rk4_dp8.is_open() || !fout_diff_rk6_dp8.is_open()) {
        std::cerr << "Ошибка открытия файлов!\n";  // Сообщение об ошибке, если файлы не удалось открыть
        return 1;  // Завершаем программу с ошибкой
    }

    double t = 0.0;  // Начальное время моделирования
    double max_global_diff_x_rk4_dp8 = 0.0;  // Максимальная глобальная разность по x между RK4 и Dopri8
    double max_global_diff_v_rk4_dp8 = 0.0;  // Максимальная глобальная разность по v между RK4 и Dopri8
    double max_global_diff_x_rk6_dp8 = 0.0;  // Максимальная глобальная разность по x между RK6 и Dopri8
    double max_global_diff_v_rk6_dp8 = 0.0;  // Максимальная глобальная разность по v между RK6 и Dopri8

    // Основной цикл по времени
    for (int i = 0; i < steps; i++) {
        double sum_diff_x_rk4_dp8 = 0.0;  // Сумма разностей по x для вычисления среднего (RK4 vs Dopri8)
        double sum_diff_v_rk4_dp8 = 0.0;  // Сумма разностей по v для вычисления среднего (RK4 vs Dopri8)
        double sum_diff_x_rk6_dp8 = 0.0;  // Сумма разностей по x для вычисления среднего (RK6 vs Dopri8)
        double sum_diff_v_rk6_dp8 = 0.0;  // Сумма разностей по v для вычисления среднего (RK6 vs Dopri8)

        // Цикл по частицам: запись данных и вычисление ошибок
        for (int j = 0; j < N; j++) {
            fout_rk4 << particles_rk4[j].x << " " << particles_rk4[j].v << " ";  // Записываем x и v для RK4
            fout_dp8 << particles_dp8[j].x << " " << particles_dp8[j].v << " ";  // Записываем x и v для Dopri8
            fout_rk6 << particles_rk6[j].x << " " << particles_rk6[j].v << " ";  // Записываем x и v для RK6

            // Разности между RK4 и Dopri8
            double diff_x_rk4_dp8 = std::abs(particles_rk4[j].x - particles_dp8[j].x);  // Разность по x
            double diff_v_rk4_dp8 = std::abs(particles_rk4[j].v - particles_dp8[j].v);  // Разность по v
            sum_diff_x_rk4_dp8 += diff_x_rk4_dp8;  // Накапливаем сумму разностей по x
            sum_diff_v_rk4_dp8 += diff_v_rk4_dp8;  // Накапливаем сумму разностей по v
            max_global_diff_x_rk4_dp8 = std::max(max_global_diff_x_rk4_dp8, diff_x_rk4_dp8);  // Обновляем глобальный максимум по x
            max_global_diff_v_rk4_dp8 = std::max(max_global_diff_v_rk4_dp8, diff_v_rk4_dp8);  // Обновляем глобальный максимум по v

            // Разности между RK6 и Dopri8
            double diff_x_rk6_dp8 = std::abs(particles_rk6[j].x - particles_dp8[j].x);  // Разность по x
            double diff_v_rk6_dp8 = std::abs(particles_rk6[j].v - particles_dp8[j].v);  // Разность по v
            sum_diff_x_rk6_dp8 += diff_x_rk6_dp8;  // Накапливаем сумму разностей по x
            sum_diff_v_rk6_dp8 += diff_v_rk6_dp8;  // Накапливаем сумму разностей по v
            max_global_diff_x_rk6_dp8 = std::max(max_global_diff_x_rk6_dp8, diff_x_rk6_dp8);  // Обновляем глобальный максимум по x
            max_global_diff_v_rk6_dp8 = std::max(max_global_diff_v_rk6_dp8, diff_v_rk6_dp8);  // Обновляем глобальный максимум по v
        }

        // Вычисляем средние локальные разности
        double avg_local_diff_x_rk4_dp8 = sum_diff_x_rk4_dp8 / N;  // Средняя локальная ошибка по x (RK4 vs Dopri8)
        double avg_local_diff_v_rk4_dp8 = sum_diff_v_rk4_dp8 / N;  // Средняя локальная ошибка по v (RK4 vs Dopri8)
        double avg_local_diff_x_rk6_dp8 = sum_diff_x_rk6_dp8 / N;  // Средняя локальная ошибка по x (RK6 vs Dopri8)
        double avg_local_diff_v_rk6_dp8 = sum_diff_v_rk6_dp8 / N;  // Средняя локальная ошибка по v (RK6 vs Dopri8)

        // Записываем локальные разности в файлы
        fout_diff_rk4_dp8 << avg_local_diff_x_rk4_dp8 << " " << avg_local_diff_v_rk4_dp8 << "\n";  // Локальные разности RK4 vs Dopri8
        fout_diff_rk6_dp8 << avg_local_diff_x_rk6_dp8 << " " << avg_local_diff_v_rk6_dp8 << "\n";  // Локальные разности RK6 vs Dopri8

        fout_rk4 << "\n";  // Переход на новую строку после записи всех частиц для RK4
        fout_dp8 << "\n";  // Переход на новую строку после записи всех частиц для Dopri8
        fout_rk6 << "\n";  // Переход на новую строку после записи всех частиц для RK6

        // Обновление состояния всех частиц на следующем шаге
        for (int j = 0; j < N; j++) {
            rk_step(particles_rk4[j], t, dt, c_rk4, a_rk4, b_rk4, stages_rk4, delta, alpha, beta, gamma, omega);  // Шаг RK4
            dp8_step(particles_dp8[j], t, dt, k_last[j], (i == 0), c_dp8, a_dp8, b_dp8, delta, alpha, beta, gamma, omega);  // Шаг Dopri8 с FSAL
            rk_step(particles_rk6[j], t, dt, c_rk6, a_rk6, b_rk6, stages_rk6, delta, alpha, beta, gamma, omega);  // Шаг RK6
        }
        t += dt;  // Увеличиваем время на шаг dt
    }

    // Закрываем файлы после записи всех данных
    fout_rk4.close();
    fout_dp8.close();
    fout_rk6.close();
    fout_diff_rk4_dp8.close();
    fout_diff_rk6_dp8.close();

    // Выводим итоговые сообщения в консоль
    std::cout << "Готово! Данные сохранены в 'duffing_rk4.dat', 'duffing_dp8.dat', 'duffing_rk6.dat', 'diff_rk4_dp8.dat' и 'diff_rk6_dp8.dat'.\n";
    std::cout << "Максимальная глобальная разница по x (RK4 vs Dopri8): " << max_global_diff_x_rk4_dp8 << "\n";  // Максимальная разность по x (RK4 vs Dopri8)
    std::cout << "Максимальная глобальная разница по v (RK4 vs Dopri8): " << max_global_diff_v_rk4_dp8 << "\n";  // Максимальная разность по v (RK4 vs Dopri8)
    std::cout << "Максимальная глобальная разница по x (RK6 vs Dopri8): " << max_global_diff_x_rk6_dp8 << "\n";  // Максимальная разность по x (RK6 vs Dopri8)
    std::cout << "Максимальная глобальная разница по v (RK6 vs Dopri8): " << max_global_diff_v_rk6_dp8 << "\n";  // Максимальная разность по v (RK6 vs Dopri8)

    return 0;
}